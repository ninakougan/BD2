# -*- coding: utf-8 -*-
"""
MID_BD2.py

Monetary incentive delay task with valences for reward/loss and a neutral
condition, for 6 total trial types.

Presentation times vary based on a staircase procedure calibrated to reach 66%
success.

A run is currently 36 trials; run orders and fixation timings generated by Jeanette Mumford.
To change run length would require regenerating new order files.

Based on code originally written by @nivreggev, see README; Modified by Haroon Popal (hspopal on GitHub)
Last modified by Nina Kougan (ninakougan@u.northwestern.edu) on 04/08/25

***NOTES FROM NINA FOR BERKELEY TESTING***
To change number of trials, see line 59 and 585
To change ITI values, see line 72 (equation needs to = number of trials per run)
To change button box inputs, see lines 87-95
To change # of trials during MRT, see line 575

"""


from psychopy import gui, visual, core, data, event, logging, monitors
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)
from numpy.random import random, shuffle
import random
import os
import csv
import pandas as pd
import numpy as np
import time
from pathlib import Path
import warnings


warnings.filterwarnings("ignore", category=DeprecationWarning)
logging.console.setLevel(logging.CRITICAL)


############################################################################
# SET UP
############################################################################

# Setting up some user-defined variables
DEBUG = True
expName = "MRT"
version = "1.1_practice"
data_dir = "../data/" # location of outputs to be generated
stim_dir = "../stimuli/"
inst_dir = stim_dir+"instructions/" # location of instructions directory

# Three runs, first is the calibration run (MRT task)
num_runs = 1
# Trials per run
num_trials = 36

pre_instructions_duration = 10 # added time before instructions to acclimate to scanner
initial_fix_duration = 5 # added time to make sure homogenicity of magnetic field is reached
closing_duration = 8.0 # added time at end of last run to make sure we capture enough

# Trial times
cue_time = 2.0 # How long the cue is displayed (in seconds)
fix_after_cue_range = [2.0,2.5]  # Inter-stimulus interval
min_target_dur = 0.1 # Sets the minimum presentation time for target (in seconds)
inital_target_dur = 0.5 # Initial presentation of target (in seconds)
isi_target_isi_time = 4  # Total time between end of cue, and right before feedback
feedback_time = 2.0 # How long the trial + total reward feedback is displayed (in seconds)
fix_ITI = [2, 4, 6] * 12  # Inter-trial interval timings

# Define speed up/down factor for increasing target window time based on performance
single_speed_factor = 0.02  # This will add or subject 20ms


total_earnings = 0
total_earnings_goal = 40


# Set tracker for number of MRT reruns
num_reruns = 0


# Accepted inputs
forwardKeys = ['1','6']
backKey = '2'
startKeys = ['enter','return']
fMRI_trigger = ['5']  # This is the fMRI trigger button that starts the task
ttlKey = "5"
expKeys = ['1','2','6']
escapeKeys = ['escape', 'esc']
rerun_MRT = 'r'
end_MRT_Keys = startKeys + [rerun_MRT]


# Start set up of the experiment

# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Initialization
expName = expName + version
expInfo = {
    'participant': '',
    'session': '1',
    'fMRI? (yes or no)': 'no',
    'fMRI trigger on TTL? (yes or no)': 'no',
    'fMRI reverse screen? (yes or no)': 'no',
}
dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
sn = int(expInfo['participant'])
session = int(expInfo['session'])
task_screen = 2 #int(expInfo['task screen'])

# Check for various experimental handles
if expInfo['fMRI? (yes or no)'].lower() == 'yes':
    fmri = True
else:
    fmri = False

if expInfo['fMRI trigger on TTL? (yes or no)'].lower() == 'yes':
    triggerOnTTL = True
else:
    triggerOnTTL = False

if expInfo['fMRI reverse screen? (yes or no)'].lower() == 'yes':
    flipHoriz = True
else:
    flipHoriz = False

# Define run number based on experimentor input
run = 0 #int(expInfo['start run (0-2)'])



# Defining some initialization functions
# Create the presentation scree
def make_screen(screen):
    """
    Generates screen variables.
    WIMR scanner screen is set to 800x600 for a different task,
    so keep that resolution since bars on the side do not affect this.
    """
    if fmri:
        win_res = [800, 600]
        #screen=1
    else:
        win_res = [1920, 1080]
        screen=0
    exp_mon = monitors.Monitor('exp_mon')
    exp_mon.setSizePix(win_res)
    
    win = visual.Window(size=win_res, screen=screen, allowGUI=True,
                        fullscr=True, monitor=exp_mon, units='height',
                        color="Black")
    return(win_res, win)

# Define a function to track the data
def start_datafiles(_thisDir, expName, expInfo, data_dir, sn, session, fmri):
    """Creates name for datafile (after checking for old one)"""
    pad = 4-len(str(sn))
    snstr = '0'*pad + str(sn)
    fname = expName + '_' + snstr
    if os.path.exists(fname):
        if i == fname + '.csv':
            warndlg = gui.Dlg(title='Warning!')
            warndlg.addText('A data file with this number already exists.')
            warndlg.addField('Overwrite?\t\t', initial="no")
            warndlg.addField('If no, new SN:\t', initial='0')
            warndlg.show()
            if gui.OK:
                over = warndlg.data[0].lower() == 'no'
            else:
                core.quit()
            if over:
                sn = int(warndlg.data[1])
                pad = 4-len(str(sn))
                snstr = '0'*pad + str(sn)
                fname = expName + '_' + snstr
    filename = _thisDir + os.sep + data_dir + os.sep + snstr + os.sep + fname + '_ses-'+str(session)
    print('\n\n'+filename+'\n\n')
    return(filename)

# Function for displaying instructions
def display_instructions_file(inst_file, instructions, run):
    inname = _thisDir + os.sep + inst_dir + os.sep + inst_file
    infile = pd.read_csv(inname)

    instr_images = list(infile['images'])
    endOfInstructions = False
    instructLine = 0

    while not endOfInstructions:
        
        if run == 0:
            instructPrompt.setText(instructions[instructLine])
            instructPrompt.draw()
            
            # Present image if relevant
            if instr_images[instructLine] != 'none' and run == 0:
                inst_target = visual.Polygon(win, edges=3, radius=0.1, 
                                            fillColor="white", pos=(0,yScr/10))
                inst_target.draw()
                
            instructMove.draw()
            win.flip()
            
        else:
            if instr_images[instructLine] == 'none':
                instructPrompt.setText(instructions[instructLine])
                instructPrompt.draw()
                instructMove.draw()
                win.flip()
            
            else:    
                fix1_exmp = visual.TextStim(win, pos=[-0.65, 0.15], 
                                            text='+', height=fontH*2, 
                                            color=text_color, 
                                            flipHoriz=flipHoriz)
                cuex_exmp = visual.ImageStim(win, pos=[-0.35,0.15], size=0.2,
                                             image=stim_dir+"reward_high.png")
                fix2_exmp = visual.TextStim(win, pos=[-0.15, 0.15], text='+', 
                                            height=fontH*2, color=text_color, 
                                            flipHoriz=flipHoriz)
                targ_exmp = visual.Polygon(win, pos=[0.15,0.15], edges=3, 
                                           radius=0.1, fillColor="white")
                fix3_exmp = visual.TextStim(win, pos=[0.35, 0.15], text='+', 
                                            height=fontH*2, color=text_color, 
                                            flipHoriz=flipHoriz)
                fdbk_exmp = visual.TextStim(win, pos=[0.65, 0.15], 
                                            text='Hit!\n+$5.00', 
                                            height=fontH*2, 
                                            color=text_color, 
                                            flipHoriz=flipHoriz)
                
                # Draw bottom row of page
                fix1_desc = visual.TextStim(win, pos=[-0.65, -0.15], 
                                            text='Pay attention', 
                                            height=fontH, wrapWidth=0.1,
                                            color=text_color, 
                                            flipHoriz=flipHoriz,
                                            alignHoriz='center')
                cuex_desc = visual.TextStim(win, pos=[-0.35, -0.15], 
                                            text="Cue: don't respond yet", 
                                            height=fontH, wrapWidth=0.1,
                                            color=text_color, 
                                            flipHoriz=flipHoriz, 
                                            alignHoriz='center')
                fix2_desc = visual.TextStim(win, pos=[-0.15, -0.15], 
                                            text='Pay attention', 
                                            height=fontH, wrapWidth=0.1,
                                            color=text_color, 
                                            flipHoriz=flipHoriz, 
                                            alignHoriz='center')
                targ_desc = visual.TextStim(win, pos=[0.15, -0.15], 
                                            text='Respond when solid triangle is on screen', 
                                            height=fontH, wrapWidth=0.1,
                                            color=text_color, 
                                            flipHoriz=flipHoriz, 
                                            alignHoriz='center')
                fix3_desc = visual.TextStim(win, pos=[0.35, -0.15], 
                                            text='Pay attention', 
                                            height=fontH, wrapWidth=0.1,
                                            color=text_color, 
                                            flipHoriz=flipHoriz, 
                                            alignHoriz='center')
                fdbk_desc = visual.TextStim(win, pos=[0.65, -0.15], 
                                            text='Feedback', height=fontH, 
                                            wrapWidth=0.1, color=text_color, 
                                            flipHoriz=flipHoriz, 
                                            alignHoriz='center')
                
                fix1_exmp.draw()
                cuex_exmp.draw()
                fix2_exmp.draw()
                targ_exmp.draw()
                fix3_exmp.draw()
                fdbk_exmp.draw()
                fix1_desc.draw()
                cuex_desc.draw()
                fix2_desc.draw()
                targ_desc.draw()
                fix3_desc.draw()
                fdbk_desc.draw()
                
                win.flip()
        
        instructRep = event.waitKeys(keyList=expKeys)
        if instructRep[0] == backKey:
                instructLine -= 1
        elif instructRep[0] in forwardKeys:
            instructLine += 1
        if instructLine >= len(instructions):
            endOfInstructions = True




# Data file name creation; later add .psyexp, .csv, .log, etc
filename = start_datafiles(_thisDir, expName, expInfo, data_dir, sn, session, 
                           fmri)

# An ExperimentHandler isn't essential but helps with data saving
exp = data.ExperimentHandler(name=expName, version=version, 
                             extraInfo=expInfo, runtimeInfo=None,
                             originPath=None, savePickle=True, 
                             saveWideText=True, dataFileName=filename)

# Save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

# Setup the window and presentation constants
[win_res, win] = make_screen(task_screen)
yScr = 1.
xScr = float(win_res[0])/win_res[1]
fontH = yScr/25
wrapW = xScr/1.5
text_color = 'white'

# Store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None and expInfo['frameRate'] < 300:
    frame_duration = 1.0 / round(expInfo['frameRate'])
else:
    frame_duration = 1.0 / 60.0  # could not measure, so guess

# Create a message at the bottom of the screen to tell subject to proceed
instructMoveText = f"Press the button to continue."
instructMove = visual.TextStim(win, text=instructMoveText, height=fontH, 
                                color=text_color, pos=[0, -yScr/4], 
                                flipHoriz=flipHoriz)


# Start component code to be run before the window creation

# Create fixation stimulus
fix = visual.TextStim(win, pos=[0, 0], text='+', height=fontH*2, 
                      color=text_color, flipHoriz=flipHoriz)
clock = core.Clock()

# Pre-instructions
instructPre = visual.TextStim(win, text="Please wait.\n\nThe task instructions will begin soon.",
                                     height=fontH, color=text_color, 
                                     pos=[0, 0], wrapWidth=wrapW, 
                                     flipHoriz=flipHoriz)

# Initialize components for Routine "instructions"
instructPrompt = visual.TextStim(win=win, font='Arial', pos=(0, yScr/10), 
                                 height=fontH, wrapWidth=wrapW, 
                                 color=text_color, flipHoriz=flipHoriz);
if fmri and run > 0:
    endInstructions = "When you are ready to begin the task, place your finger on the button and notify the experimenter. The experimenter will start the task momentarily."
elif fmri and run == 0:
    endInstructions = "When you are ready to begin the task, place your finger on the button. The experimenter will start the task momentarily."
else:
    endInstructions = "When you are ready to begin the task, place your finger on the button and hit Enter to begin."

instructFinish = visual.TextStim(win, text=endInstructions,
                                     height=fontH, color=text_color, 
                                     pos=[0, 0], wrapWidth=wrapW, 
                                     flipHoriz=flipHoriz)

# Initialize components for task transitions
wait = visual.TextStim(win, pos=[0, 0], text="The task will begin momentarily. Waiting for scanner. Get ready...", height=fontH, color=text_color, flipHoriz=flipHoriz)
endf = visual.TextStim(win, pos=[0, 0], text="Thank you. This part of the experiment is now complete.",wrapWidth=wrapW, height=fontH, color=text_color, flipHoriz=flipHoriz)

# Initialize components for Routine "cue"
cues = {
    'reward.low':  visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"reward_low.png"),
    'reward.high': visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"reward_high.png"),
    'reward.neut': visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"reward_neut.png"),
    'loss.low':    visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"loss_low.png"),
    'loss.high':   visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"loss_high.png"),
    'loss.neut':   visual.ImageStim(win, size=0.3, 
                                    image=stim_dir+"loss_neut.png"),
    }
CueClock = core.Clock()

# Initialize components for Routine "Target"
TargetClock = core.Clock()
Target = visual.Polygon(win, edges=3, radius=0.2, fillColor="white", 
pos=(0,0))

# Initialize components for Routine "Feedback"
FeedbackClock = core.Clock()
trial_feedback = visual.TextStim(win=win, name='trial_feedback',
                                 text='Trial:', font='Arial', 
                                 pos=(0, 0), height=fontH+yScr/20, 
                                 wrapWidth=None, ori=0, color='White', 
                                 colorSpace='rgb', opacity=1, 
                                 flipHoriz=flipHoriz);
exp_feedback = visual.TextStim(win=win, name='exp_feedback',
                               text='Total:', font='Arial', 
                               pos=(0, -yScr/16), height=fontH+yScr/20, 
                               wrapWidth=None, ori=0, color='White', 
                               colorSpace='rgb', opacity=1, 
                               flipHoriz=flipHoriz);

breakPrompt = visual.TextStim(win, text="Take a break. When you are ready to continue, press the button.", 
                              height=fontH, color=text_color, pos=(0,0), 
                              flipHoriz=flipHoriz)
                              
waitForStructPrompt = visual.TextStim(win, text="Thank you! This part of the experiment is concluded.",
                              height=fontH, color=text_color, pos=(0,0),
                              flipHoriz=flipHoriz)

rerunPrompt = visual.TextStim(win, text="Re-running the triangle game. Try to press the button as fast as you can when the triangle appears!", 
                              height=fontH, color=text_color, pos=(0,0), 
                              flipHoriz=flipHoriz)

breakEnd = visual.TextStim(win, text="Get ready", height=fontH, 
                           color=text_color, pos=(0,0), flipHoriz=flipHoriz)
                           
waitPrompt = visual.TextStim(win, text="Please wait\n\n", 
                              height=fontH, color=text_color, pos=(0,0), 
                              flipHoriz=flipHoriz)


# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
runClock = core.Clock()  # to track the time since experiment started
trialClock = core.Clock()  # to track the time since trial started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine


# Create the staircase handlers to adjust for individual threshold
# (stairs defined in units of screen frames; actual minimum presentation
# duration is determined by the min_target_dur parameter, the staircase
# procedure can only add frame rates to that minimum value)

if run == 0:
    stepSizes = [6, 3, 3, 2, 2, 1, 1]
else:
    stepSizes = [2, 2, 1, 1]

def make_stairs(nTrials, startVal=15.0):
    return data.StairHandler(startVal=startVal,
        stepType='lin',
        stepSizes=stepSizes,
        minVal=0, maxVal=30,
        nUp=1,
        nDown=2, # will home in on the 66% threshold (nUp=1, nDown=3 homes in on 80%)
        nTrials=nTrials,
        extraInfo=expInfo)

perStim = num_runs * num_trials / 6

stairs = {
    'loss.high':   make_stairs(perStim,     15),
    'loss.low':    make_stairs(perStim,     15),
    'loss.neut':   make_stairs(perStim,     15),
    'reward.high': make_stairs(perStim,     15),
    'reward.low':  make_stairs(perStim,     15),
    'reward.neut': make_stairs(perStim,     15),
    }
staircase_end = {}


# Useful functions

def get_keypress():
    keys = event.getKeys()
    if keys:
        return keys[0]
    else:
        return None

def shutdown():
    print("Logging staircase end values and exiting...")
    stairs = ['loss.high', 'loss.low', 'loss.neut', 
              'reward.high', 'reward.low', 'reward.neut']

    logging.warning(f"Total earnings: {total_earnings}")

    logging.flush()
    win.close()
    core.quit()

def show_stim(stim, duration):
    duration = float(duration)
    t_start = globalClock.getTime()
    routineTimer.reset()
    routineTimer.addTime(duration)
    event.clearEvents(eventType='keyboard')
    rt = None
    while routineTimer.getTime() > 0:
        key = get_keypress()
        if key and key.lower() in escapeKeys:
            logging.warning("Escape pressed, exiting early!")
            shutdown()
        if not rt and key in forwardKeys:
            rt = duration - routineTimer.getTime()
        if stim:
            stim.draw()
        win.flip()
    return rt
    print('TESTING...'+str(rt)+'\n')

def show_fixation(duration):
    return show_stim(fix, duration)



############################################################################
# START EXPERIMENT
############################################################################

# Prep experiment loop

# Create stimulus presentation list
stim_conds = list(cues.keys())


# Experiment begins

# Loop the rest of this for num_runs
while run < num_runs:
    
    # Set random seed - participant, session, and run dependent
    random.seed(sn * (session + 1000 + run))
    
    # Displaying instructions

    # Keyboard checking is just starting
    event.clearEvents(eventType='keyboard')
    event.Mouse(visible=False)

    if run == 0:
        inst_file = "MRT_instructions.csv"
        instructions = ["Welcome to the triangle game!",
        "First you will see a cross in the middle of the screen, like this:\n\n+\n\n"+
        "This means you should focus on the screen and get ready to play. ",
        "Next, a small solid WHITE TRIANGLE will appear on the screen:\n\n \n\n \n\n \n\n"+
        "Press the button as fast as you can when you see the solid white triangle. ",
        "Any Questions?\n\nPlease ask them now."]
    
    else:
        inst_file = "scanner_task.csv"
        instructions = ["Instructions...\n\n"+
        "Your goal is to make as much money as possible.\n\n"+
        "Remember:\n"+
        "WIN CIRCLES = win money\n"+
        "LOSE SQUARES = lose money\n\n"+
        "QUICKLY press the button with your pointer finger when you see the solid white triangle.\n\n"+
        "You will get feedback on whether you pressed the button in time and if you won or lost money.",
        ""]
        
    
    #if fmri:
        #show_stim(instructPre, pre_instructions_duration)
    
    display_instructions_file(inst_file, instructions, run)
    
    print("end of instructions, hit enter to continue")
    logging.flush()
    instructFinish.draw()
    win.flip()
    event.waitKeys(keyList=startKeys)
    
    print("instructions complete, continuing")
    logging.flush()
    
    # Reset the non-slip timer for next routine
    routineTimer.reset()
    event.clearEvents(eventType='keyboard')
    
    # Determine order of stimuli for run
    if run == 0:  # RT run
        #stim_list = stim_conds
        # Trials per run
        num_trials = 15
        
        n_cond_reps = 3
        
        # Set the fixation after cue buffer to 0
        fix_after_cue = 0
        
        
    else:  # run 1 or 2
        # Trials per run
        num_trials = 36
    
        # Find the appropriate number of repetitions for each condition
        n_cond_reps = int(num_trials/len(stim_conds))
    
    # Set a list to capture reaction times
    trial_RTs = []
        
    # Create appropriate number of presentations for each condition type
    stim_list = stim_conds*n_cond_reps
    
    # Set/reset trial number for a new run
    trial_number = 0
    
    # Randomize stimuli order
    random.shuffle(stim_list)
    random.shuffle(fix_ITI)
    
    # Create a dataframe for the event file
    order = pd.DataFrame(np.transpose([list(np.arange(1,len(stim_list)+1)), stim_list]),
                         columns=['trial.num','trial.type'])
    
    if fmri and run > 0:
        print(f"waiting for ready, hit {startKeys} after prep scan")
        logging.flush()
        wait.draw()
        win.flip()
        event.waitKeys(keyList=fMRI_trigger)
    
    # Wait for TR signal if in scanner
    if triggerOnTTL and run > 0:
        print(f"waiting for TTL key {ttlKey} on TR")
        logging.flush()
        wait.draw()
        win.flip()
        event.waitKeys(keyList=ttlKey)
    
    print(f"starting run {run} of {num_runs-1}")
    logging.flush()
    
    runClock.reset()
    if run == 0:
        globalClock.reset() # to align actual time with virtual time keeper
    
    if DEBUG:
        print(f"actual start {globalClock.getTime()}")
    
    # Track hit accuracy
    if run == 0:
        target_durs = pd.DataFrame(columns=stairs.keys())
        target_durs.loc[0] = inital_target_dur
        
    elif run == 1:
        target_durs = pd.read_csv(filename+'_target_durs-MRT.csv')
    else:
        target_durs = pd.read_csv(filename+'_target_durs-run'+str(run-1)+'.csv')
    
    hit_tracker = pd.DataFrame(columns=stairs.keys())
    
    # present initial fixation
    if run == 0:
        print('initial fix duration: '+str(initial_fix_duration))
    show_fixation(initial_fix_duration)

    for trial in range(0, num_trials):
        if DEBUG:
            print(f'\n trial {trial + 1} of {num_trials}')
        
        # Total trial number along all runs
        trial_number += 1
        trial_details = order.iloc[trial]
        trial_type = trial_details['trial.type']
        trial_response = 0
        
        trial_stairs = stairs[trial_type]
        
        trial_duration_frames = trial_stairs.next()
        staircase_end[trial_type] = trial_duration_frames
        
        exp.addData('subid', sn)
        exp.addData('session', session)
        exp.addData('run', run)
        exp.addData('trial.system.time', time.asctime())
        
        trialClock.reset()
        
        exp.addData('trial.number', trial_number)
        exp.addData('trial.type', trial_type)
        
        def log_detail(x):
            print(f"{x}: {trial_details[x]}")
        
        
        # ------Prepare to start Routine "Cue"-------
        if run > 0:
            cue = cues[trial_type]

            # Log cue onset time
            exp.addData('Cue.OnsetTime', runClock.getTime())
            #exp.addData('Cue.Duration', cue_time)
            cue_rt = show_stim(cue, cue_time)  # Is this needed?
            if cue_rt:
                exp.addData('trial.cue_rt', cue_rt)
            
            
            # Fixation after cue is a random number between two numbers (e.g. 2-2.5s)
            fix_after_cue = random.uniform(fix_after_cue_range[0], 
                                           fix_after_cue_range[1])
            
            too_fast_rt = show_fixation(fix_after_cue)
            if too_fast_rt:
                print('too fast rt: ', too_fast_rt)
                trial_response = 2
                exp.addData('trial.too_fast_rt', too_fast_rt)
            
            # Log fixation after cue onset
            exp.addData('Dly.OnsetTime', runClock.getTime())
        
        
        # ------Prepare to start Routine "Target"-------
        t = 0
        TargetClock.reset()  # clock

        # Reset the non-slip timer for next routine
        routineTimer.reset()
        continueRoutine = True
           
        routineTimer.addTime(target_durs.loc[0,trial_type])
        
        # Update component parameters for each repeat
        target_response = event.BuilderKeyResponse()
        rt = None
        
        # Keep track of which components have finished
        TargetComponents = [Target, target_response]
        for thisComponent in TargetComponents:
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
                
        
        # -------Start Routine "Target"-------
        # Log target onset time
        exp.addData('Tgt.OnsetTime', runClock.getTime())
        
        while continueRoutine and routineTimer.getTime() > 0:
            # Get current time
            t = TargetClock.getTime()
            
            # Selection screen updates
            if t >= 0.0 and Target.status == NOT_STARTED:
                # Keep track of start time/frame for later
                Target.tStart = t
                # Display target
                Target.setAutoDraw(True)
                # Open response options
                target_response.tStart = t
                target_response.status = STARTED
                # Keyboard checking is just starting
                win.callOnFlip(target_response.clock.reset)  # t=0 on next screen flip
                event.clearEvents(eventType='keyboard')
                theseKeys = []
                
            if Target.status == STARTED and t <= target_durs.loc[0,trial_type]:
                Target.setAutoDraw(True)
                theseKeys = event.getKeys(keyList=forwardKeys)

                if len(theseKeys) > 0:  
                    rt = target_response.clock.getTime()
                    target_response.rt = rt
                    if trial_response == 0:
                        trial_response = 1
            
            # Check if all components have finished
            if not continueRoutine:
                break
            continueRoutine = False
            for thisComponent in TargetComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # At least one component has not yet finished
            
            # Draw fixation if we're done, so we don't leave a blank screen for any frames
            if not continueRoutine:
                fix.draw()
            win.flip()
                
                
        # -------Ending Routine "Target"-------
        for thisComponent in TargetComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        
        # Add the data to the current staircase so it can be used to calculate the next level
        trial_stairs.addResponse(trial_response)
        
        # Check responses to add RT
        trial_type_count = hit_tracker[trial_type].count()
        if trial_response == 1:
            exp.addData('trial.rt', target_response.rt)
            exp.addData('trial.target_dur', round(target_durs.loc[0,trial_type], 
                                                  3))
            print(f"response: {target_response.rt}")
            hit_tracker.loc[trial_type_count,trial_type] = 1
            trial_RTs.append(rt)
        elif trial_response == 2 and rt:
            exp.addData('trial.rt', target_response.rt)
            exp.addData('trial.target_dur', round(target_durs.loc[0,trial_type], 
                                                  3))
            print(f"response: {target_response.rt}")
            hit_tracker.loc[trial_type_count,trial_type] = 0
        else:
            exp.addData('trial.target_dur', round(target_durs.loc[0,trial_type], 
                                                  3))
            print(f"response: none during stim")
            hit_tracker.loc[trial_type_count,trial_type] = 0
            trial_RTs.append(target_durs.loc[0,trial_type])
        logging.flush()
        
        # Calculate trial condition hit rate
        hit_rate = hit_tracker[trial_type].sum() / hit_tracker[trial_type].count()
        
        if hit_rate >= 0.66:
            target_durs.loc[0,trial_type] -= single_speed_factor  # subtract 20ms
        else:
            target_durs.loc[0,trial_type] += single_speed_factor  # add 20ms
        
        print(trial_type + ' duration is: '+str(target_durs.loc[0,trial_type]))
        if target_durs.loc[0,trial_type] < min_target_dur:
            target_durs.loc[0,trial_type] = min_target_dur
        routineTimer.addTime(target_durs.loc[0,trial_type])

        reward = 0

        # Update trial components
        if trial_type == 'reward.high' and trial_response == 1:
            reward = 5.0
            exp.addData('trial.reward', reward)
        elif trial_type == 'reward.low' and trial_response == 1:
            reward = 1.5
            exp.addData('trial.reward', reward)
        elif trial_type == 'reward.neut' and trial_response == 1:
            reward = 0.0
            exp.addData('trial.reward', reward)
        elif trial_type == 'loss.high' and not trial_response == 1:
            reward = -5.0
            exp.addData('trial.reward', reward)
        elif trial_type == 'loss.low' and not trial_response == 1:
            reward = -1.5
            exp.addData('trial.reward', reward)
        elif trial_type == 'loss.neut' and not trial_response == 1:
            reward = 0.0
            exp.addData('trial.reward', '-' + str(reward))
        
        total_earnings += reward
        if DEBUG:
            print(f"{trial_type} result: {trial_response}, reward is {reward} for total {total_earnings}" )
        
        # Fixation after stim target
        
        exp.addData('Fix_after_target.OnsetTime', runClock.getTime())
        
        # Set the fixation after target by accounting for the variable target
        # time window
        if rt:
            fix_after_target = isi_target_isi_time - fix_after_cue - rt
        else:
            fix_after_target = isi_target_isi_time - fix_after_cue - target_durs.loc[0,trial_type]
        
        too_slow_rt = show_fixation(fix_after_target)
        if too_slow_rt:
            print('too slow rt: ', too_slow_rt)
            trial_response = 3
            exp.addData('trial.too_slow_rt', too_slow_rt)
        
        
        # ------Prepare to start Routine "Feedback"-------
        if run > 0:
            t = 0
            FeedbackClock.reset()  # clock
            # Reset the non-slip timer for next routine
            routineTimer.reset()
            continueRoutine = True
            routineTimer.addTime(feedback_time)
            
            def trial_cash_string(r, trial_response):
                if r > 0:
                    return f"Hit!\n+${r:.2f}"
                elif r < 0:
                    return f"Miss!\n-${abs(r):.2f}"
                elif trial_response == 1:
                    return f"Hit!\n${r:.2f}"
                elif trial_type == 'loss.neut':
                    return f"Miss!\n-${r:.2f}"
                else:
                    return f"Miss!\n${r:.2f}"
            
            def total_cash_string(r):
                if r < 0:
                    return f"Miss!\n${r:.2f}"
                else:
                    return f"${r:.2f}"

            trial_feedback.setText(trial_cash_string(reward, trial_response))        
            exp.addData("Tgt.ACC", trial_response)
            exp.addData('Tgt.ACCfeedback', trial_cash_string(reward, trial_response))
            exp.addData('total_earnings', total_earnings)
            
            # Keep track of which components have finished
            FeedbackComponents = [trial_feedback, exp_feedback]
            for thisComponent in FeedbackComponents:
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            
            
            # -------Start Routine "Feedback"-------
            
            # Log feedback onset time
            exp.addData('Fb.OnsetTime', runClock.getTime())
            
            while continueRoutine and routineTimer.getTime() > 0:
                # Get current time
                t = FeedbackClock.getTime()

                # Feedback screen updates
                if t >= 0.0 and trial_feedback.status == NOT_STARTED:
                    # Keep track of start time/frame for later
                    trial_feedback.tStart = t
                    trial_feedback.setAutoDraw(True)
                frameRemains = 0.0 + feedback_time - win.monitorFramePeriod * 0.75  # most of one frame period left
                if trial_feedback.status == STARTED and t >= frameRemains:
                    trial_feedback.setAutoDraw(False)

                # Check if all components have finished
                if not continueRoutine:
                    break
                continueRoutine = False
                for thisComponent in FeedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # At least one component has not yet finished

                # Refresh the screen
                if continueRoutine:  # Don't flip if this routine is over or we'll get a blank screen
                    win.flip()
        
            # -------Ending Routine "Feedback"-------
            for thisComponent in FeedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
        
        # Fixation after stim target
        # We want this to be altered so that the length
        # of the trial is adjusted by the stim difference from 0.5s...

        trial_time = trialClock.getTime()
                
        # Log inter trial interval fixation time
        exp.addData('Fix_ITI.OnsetTime', runClock.getTime())
        
        show_fixation(fix_ITI[trial])
        
        # Completed trial, add some data to log file
        exp.addData('Fix_ITI.Duration', fix_ITI[trial])
        exp.addData('time.trial', trialClock.getTime())
        exp.addData('time.global', globalClock.getTime())
        
        exp.addData('Winnings', total_earnings)
        
        
        # Save mean RT to output
        if trial == num_trials-1:
            exp.addData('MRT', np.mean(trial_RTs))
        
        
        # Advance to next trial/line in logFile
        exp.nextEntry()
    
    
    if run == 0:
        # Set target durations for the average across all conditions
        target_durs.loc[0] = target_durs.loc[0].mean()
    
    # Export target durations and run data
    if run == 0:
        target_durs.to_csv(filename+'_target_durs-MRT.csv', index=False)
    else:
        target_durs.to_csv(filename+'_target_durs-run'+str(run)+'.csv', index=False)
    
    
    
    
    if run == 0:
        
        # If MRT is too slow, rerun MRT run
        print("\n\n\nAll reaction times:")
        print(trial_RTs)
        print("\nThe MRT is: "+str(np.mean(trial_RTs)))
        if np.mean(trial_RTs) > 0.350 and num_reruns == 0:
            print("Reaction times were too slow. Rerunning MRT.")
            run = -1
            num_reruns += 1
            rerunPrompt.draw()
            win.flip()
            core.wait(10)
        else:
            total_earnings = 0
            waitForStructPrompt.draw()
            win.flip()
            event.waitKeys(keyList=startKeys)
        
        #waitPrompt.draw()
        #win.flip()
        print("\n\n\n")
        
        # If done with the practice run, show the post-practice stuff
        
        
    elif run < num_runs - 1:
        # If we are still going and NOT on the last run, show the break messages
        breakPrompt.draw()
        win.flip()
        event.waitKeys(keyList=forwardKeys)
    else:
        # We are on the last run
        show_stim(None, closing_duration)
    
    run += 1



# Completed experimental phase

# End of task message
#endf.draw()
#win.flip()
print("end of task reached, hit enter to save results and close")
event.waitKeys(keyList=startKeys)

shutdown()
